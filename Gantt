<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cronograma Misión CLARION - Gantt Detallado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #334155;
            padding: 20px;
        }
        .gantt-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-x: auto; /* Permite scroll horizontal si es muy largo */
        }
        .gantt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 15px;
        }
        
        /* Estilos SVG */
        svg {
            display: block;
            /* min-width calculado dinámicamente en JS */
        }
        .grid-line {
            stroke: #e2e8f0;
            stroke-width: 1;
        }
        .grid-line-weekend {
            fill: #f1f5f9; /* Color de fondo para fines de semana */
        }
        .row-separator {
            stroke: #e2e8f0; 
            stroke-width: 1;
        }
        .day-label {
            font-size: 10px;
            fill: #64748b;
            text-anchor: middle;
        }
        .month-label {
            font-size: 12px;
            font-weight: bold;
            fill: #334155;
        }
        
        /* Barra de la Tarea (Sólida) */
        .task-bar {
            rx: 4;
            ry: 4;
            transition: opacity 0.3s;
            cursor: pointer;
        }
        .task-bar:hover {
            opacity: 0.8;
        }
        
        /* Barra de Holgura (Suave) - Margen de tiempo */
        .task-slack {
            rx: 4;
            ry: 4;
            fill-opacity: 0.2; 
            pointer-events: none; 
        }

        /* Tareas Críticas (Borde negro) */
        .critical-task {
            stroke: #0f172a;
            stroke-width: 1.5;
        }

        .task-text {
            font-size: 11px;
            fill: #1e293b;
            font-weight: 500;
            dominant-baseline: middle;
            text-shadow: 0px 0px 3px white; /* Halo blanco para legibilidad sobre líneas */
        }

        .dependency-line {
            stroke: #64748b;
            stroke-width: 1.5;
            fill: none;
            marker-end: url(#arrow);
            opacity: 0.6;
            transition: opacity 0.2s, stroke 0.2s;
        }
        .dependency-line:hover {
            opacity: 1;
            stroke: #0f172a;
            stroke-width: 2;
        }
        
        /* Tooltip */
        #tooltip {
            position: absolute;
            background: #1e293b;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            max-width: 280px;
            line-height: 1.4;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* Colores por bloque */
        .color-b1 { fill: #3b82f6; } /* Azul */
        .color-b2 { fill: #8b5cf6; } /* Violeta */
        .color-b3 { fill: #10b981; } /* Verde */
        .color-b4 { fill: #f59e0b; } /* Ambar */
        .color-b5 { fill: #ef4444; } /* Rojo */
        .color-b6 { fill: #06b6d4; } /* Cyan */
        .color-b7 { fill: #ec4899; } /* Rosa */
        .color-b8 { fill: #6366f1; } /* Indigo */

    </style>
</head>
<body>

<div class="max-w-full mx-auto">
    <div class="gantt-header">
        <div>
            <h1 class="text-2xl font-bold text-slate-800">Cronograma Acelerado - CLARION</h1>
            <p class="text-sm text-slate-500">
                Inicio: <strong>01 Nov 2025</strong> &mdash; MCR: <strong>03 Dic 2025</strong> (33 Días Totales)
            </p>
        </div>
        <div class="text-right flex items-center space-x-4">
             <span class="inline-flex items-center space-x-1">
                <svg width="12" height="12"><rect width="12" height="12" class="color-b5 critical-task" rx="2" ry="2" /></svg>
                <span class="text-xs text-slate-600">Ruta Crítica</span>
            </span>
            <span class="inline-flex items-center space-x-1">
                <svg width="12" height="12"><rect width="12" height="12" class="color-b5 task-slack" rx="2" ry="2" /></svg>
                <span class="text-xs text-slate-600">Holgura</span>
            </span>
        </div>
    </div>

    <div class="gantt-container" id="chart-container">
        </div>
</div>

<div id="tooltip"></div>

<script>
    // --- CONFIGURACIÓN DE FECHAS ---
    const START_DATE = new Date(2025, 10, 1); // Mes 10 es Noviembre (0-indexed)
    
    // Función para sumar días a la fecha de inicio
    function getDateFromDayOffset(offset) {
        const date = new Date(START_DATE);
        date.setDate(date.getDate() + offset);
        return date;
    }

    function formatDate(date) {
        const d = date.getDate();
        const m = date.toLocaleString('es-ES', { month: 'short' });
        return `${d} ${m}`;
    }

    // --- DATOS DEL PROYECTO (Ajustados a Días) ---
    // Total objetivo: ~33 días.
    // Duraciones en DÍAS laborables (aprox)
    
    const tasks = [
        // Bloque 1: Definición (Nov 1 - Nov 3)
        { id: "1.1", name: "Kick-off + alineación", duration: 1, block: 1, dep: [] },
        { id: "1.2", name: "Definir problema y objetivos", duration: 2, block: 1, dep: ["1.1"] },
        { id: "1.3", name: "Definir alcance preliminar", duration: 1, block: 1, dep: ["1.2"] }, // Paralelo
        { id: "1.4", name: "Identificar restricciones", duration: 1, block: 1, dep: ["1.2"] },  // Paralelo
        
        // Bloque 2: Concepto Operativo (Nov 4 - Nov 7)
        { id: "2.1", name: "Definir escenarios operativos", duration: 2, block: 2, dep: ["1.3", "1.4"] },
        { id: "2.2", name: "Definir modos de misión", duration: 1, block: 2, dep: ["2.1"] },
        { id: "2.3", name: "Definir segmentos", duration: 1, block: 2, dep: ["2.1"] },
        { id: "2.4", name: "Diagrama secuencia ops", duration: 1, block: 2, dep: ["2.2", "2.3"] },

        // Bloque 3: Arquitectura (Nov 8 - Nov 12)
        { id: "3.1", name: "Alternativas plataforma", duration: 2, block: 3, dep: ["2.4"] },
        { id: "3.2", name: "Alternativas payload", duration: 2, block: 3, dep: ["2.4"] }, // Payload suele ser driver
        { id: "3.3", name: "Alternativas órbita", duration: 2, block: 3, dep: ["2.4"] },

        // Bloque 4: Análisis (Nov 13 - Nov 17)
        { id: "4.1", name: "Análisis desempeño orbital", duration: 2, block: 4, dep: ["3.3"] },
        { id: "4.2", name: "Análisis comunicaciones", duration: 2, block: 4, dep: ["3.1", "4.1"] },
        { id: "4.3", name: "Est. consumo potencia", duration: 2, block: 4, dep: ["3.1", "3.2"] },
        { id: "4.4", name: "Viabilidad vigilancia ISS", duration: 1, block: 4, dep: ["4.1", "4.2", "4.3"] },

        // Bloque 5: Programática (Nov 18 - Nov 21)
        // Se puede hacer en paralelo al análisis técnico parcialmente
        { id: "5.1", name: "WBS Nivel 1-2 + dicc.", duration: 2, block: 5, dep: ["3.1", "3.2"] },
        { id: "5.2", name: "Estimación ROM Costos", duration: 1, block: 5, dep: ["5.1"] },
        { id: "5.3", name: "Estimación ROM Crono", duration: 1, block: 5, dep: ["5.1"] },
        { id: "5.4", name: "Identificación riesgos", duration: 2, block: 5, dep: ["4.4", "5.1"] },

        // Bloque 6: Selección (Nov 22 - Nov 24)
        { id: "6.1", name: "Matriz de decisión", duration: 2, block: 6, dep: ["4.4", "5.2", "5.3", "5.4"] },
        { id: "6.2", name: "Selección Baseline", duration: 1, block: 6, dep: ["6.1"] },

        // Bloque 7: Documentación (Nov 25 - Nov 30)
        { id: "7.1", name: "Preparar doc. MCR", duration: 4, block: 7, dep: ["6.2"] },
        { id: "7.2", name: "Ensayar presentación", duration: 1, block: 7, dep: ["7.1"] },
        { id: "7.3", name: "Correcciones finales", duration: 1, block: 7, dep: ["7.2"] },

        // Bloque 8: Revisión (Dic 1 - Dic 3)
        { id: "8.1", name: "Envío Previo", duration: 1, block: 8, dep: ["7.3"] }, // Buffer day
        { id: "8.2", name: "REVISIÓN MCR (HITO)", duration: 1, block: 8, dep: ["8.1"] } // Debe caer el 3 de Dic
    ];

    // --- CÁLCULO DE FECHAS (CPM) ---
    const calculateSchedule = (tasks) => {
        const forwardPass = {}; 
        const taskMap = {};
        tasks.forEach((task, index) => taskMap[task.id] = { ...task, index });

        // Forward Pass (ES, EF)
        const getES = (taskId) => {
            const task = taskMap[taskId];
            if (!task) return 0;
            if (forwardPass[taskId]) return forwardPass[taskId].ES;

            if (!task.dep || task.dep.length === 0) {
                forwardPass[taskId] = { ES: 0, EF: task.duration };
                return 0;
            }

            let maxEF = 0;
            task.dep.forEach(depId => {
                const depEF = getES(depId) + taskMap[depId].duration;
                if (depEF > maxEF) maxEF = depEF;
            });

            forwardPass[taskId] = { ES: maxEF, EF: maxEF + task.duration };
            return maxEF;
        };
        
        tasks.forEach(task => getES(task.id));

        // Project Duration (PD)
        let PD = 0;
        Object.values(forwardPass).forEach(s => { if(s.EF > PD) PD = s.EF; });
        
        // Backward Pass (LS, LF, Slack)
        const schedule = {};
        tasks.forEach(task => {
            schedule[task.id] = { ...forwardPass[task.id], LS: 0, LF: PD, S: 0, isCritical: false };
        });

        for (let i = tasks.length - 1; i >= 0; i--) {
            const taskId = tasks[i].id;
            const task = taskMap[taskId];
            const currentSchedule = schedule[taskId];
            
            const successors = tasks.filter(t => t.dep.includes(taskId));
            let minLS = PD;

            if (successors.length > 0) {
                successors.forEach(succ => {
                    if (schedule[succ.id].LS < minLS) minLS = schedule[succ.id].LS;
                });
                currentSchedule.LF = minLS;
            } else {
                currentSchedule.LF = PD;
            }
            
            currentSchedule.LS = currentSchedule.LF - task.duration;
            currentSchedule.S = currentSchedule.LF - currentSchedule.EF;
            currentSchedule.S = parseFloat(Math.max(0, currentSchedule.S).toFixed(2));
            currentSchedule.isCritical = currentSchedule.S === 0;
        }

        return { schedule, PD };
    };

    const { schedule, PD } = calculateSchedule(tasks);
    const maxDays = Math.ceil(PD) + 2; // +2 para margen visual

    // --- RENDERIZADO SVG ---
    const dayWidth = 35; // Ancho por día en píxeles (más estrecho que semanas)
    const rowHeight = 35;
    const headerHeight = 60;
    const leftPadding = 220;
    const svgWidth = leftPadding + (maxDays * dayWidth);
    const svgHeight = headerHeight + (tasks.length * rowHeight) + 30;

    let svgHTML = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;
    let dependencyPaths = []; 
    let taskBarsHTML = []; 
    let taskNamesHTML = []; 

    // Marker definition
    svgHTML += `
    <defs>
        <marker id="arrow" markerWidth="6" markerHeight="6" refX="6" refY="3" orient="auto">
            <path d="M0,0 L6,3 L0,6" fill="#64748b" /> 
        </marker>
    </defs>`;

    // Fondo y Grid
    svgHTML += `<rect width="100%" height="100%" fill="white" />`;
    
    // Dibujar columnas de días
    let currentMonth = -1;
    for (let d = 0; d < maxDays; d++) {
        const currentDate = getDateFromDayOffset(d);
        const x = leftPadding + (d * dayWidth);
        const isWeekend = (currentDate.getDay() === 0 || currentDate.getDay() === 6); // 0 Dom, 6 Sab

        // Fondo fin de semana
        if (isWeekend) {
             svgHTML += `<rect x="${x}" y="${headerHeight}" width="${dayWidth}" height="${svgHeight}" class="grid-line-weekend" />`;
        }
        
        // Línea vertical
        svgHTML += `<line x1="${x}" y1="${headerHeight}" x2="${x}" y2="${svgHeight}" class="grid-line" />`;
        
        // Etiqueta Día (número)
        svgHTML += `<text x="${x + (dayWidth/2)}" y="${headerHeight - 10}" class="day-label">${currentDate.getDate()}</text>`;

        // Etiqueta Mes (solo cuando cambia)
        if (currentDate.getMonth() !== currentMonth) {
            const monthName = currentDate.toLocaleString('es-ES', { month: 'long' }).toUpperCase();
            svgHTML += `<text x="${x + 5}" y="${20}" class="month-label">${monthName}</text>`;
            svgHTML += `<line x1="${x}" y1="0" x2="${x}" y2="${headerHeight}" stroke="#cbd5e1" stroke-width="2" />`;
            currentMonth = currentDate.getMonth();
        }
    }

    let currentY = headerHeight;
    let currentBlock = 0;

    tasks.forEach((task, index) => {
        const s = schedule[task.id];
        const x = leftPadding + (s.ES * dayWidth); 
        const w = task.duration * dayWidth;       
        const slackW = s.S * dayWidth;            
        const colorClass = `color-b${task.block}`;
        const criticalClass = s.isCritical ? 'critical-task' : '';

        // Fechas reales para tooltip
        const startDate = getDateFromDayOffset(s.ES);
        const endDate = getDateFromDayOffset(s.EF);

        if (task.block !== currentBlock) {
            currentBlock = task.block;
        }

        // Línea Separadora Horizontal
        svgHTML += `<line x1="0" y1="${currentY}" x2="${svgWidth}" y2="${currentY}" class="row-separator" />`;
        
        // Nombre Tarea
        taskNamesHTML.push(`<text x="10" y="${currentY + (rowHeight/2)}" class="task-text" style="font-weight: ${task.name.includes("MCR") ? 'bold' : 'normal'}">${task.id} ${task.name}</text>`);

        // Barra Holgura
        if (s.S > 0) {
            const slackX = leftPadding + (s.EF * dayWidth);
            taskBarsHTML.push(`<rect x="${slackX}" y="${currentY + 8}" width="${slackW}" height="${rowHeight - 16}" class="task-slack ${colorClass}" />`);
        }
            
        // Barra Principal
        const tooltipText = `<strong>${task.name}</strong><br>
                             Inicio: ${formatDate(startDate)}<br>
                             Fin: ${formatDate(endDate)}<br>
                             Duración: ${task.duration} días<br>
                             Holgura: ${s.S} días`;
        
        taskBarsHTML.push(`<rect x="${x}" y="${currentY + 8}" width="${w}" height="${rowHeight - 16}" class="task-bar ${colorClass} ${criticalClass}" 
            onmouseover="showTooltip(evt, '${tooltipText}')" 
            onmouseout="hideTooltip()" />`);
            
        // Dependencias
        task.dep.forEach(depId => {
            const depIndex = tasks.findIndex(t => t.id === depId);
            if (depIndex !== -1) {
                const depS = schedule[depId];
                const startX = leftPadding + (depS.EF * dayWidth); 
                const startY = currentY - (index - depIndex) * rowHeight + (rowHeight/2);
                const endX = x; 
                const endY = currentY + (rowHeight/2);
                
                // Ruteo simple de flechas
                let path = "";
                if (endX > startX + 10) {
                     path = `M ${startX} ${startY} L ${endX - 5} ${startY} L ${endX - 5} ${endY} L ${endX} ${endY}`;
                } else {
                    // Loopback si está muy cerca o atrás (raro en waterfall estricto pero posible visualmente)
                     path = `M ${startX} ${startY} L ${startX + 5} ${startY} L ${startX + 5} ${endY - 5} L ${endX - 5} ${endY - 5} L ${endX - 5} ${endY} L ${endX} ${endY}`;
                }
                dependencyPaths.push(path); 
            }
        });

        currentY += rowHeight;
    });

    svgHTML += `<line x1="0" y1="${currentY}" x2="${svgWidth}" y2="${currentY}" class="row-separator" />`;

    // Renderizado por capas (Z-index en SVG es orden de aparición)
    dependencyPaths.forEach(path => svgHTML += `<path d="${path}" class="dependency-line" />`);
    taskBarsHTML.forEach(barHTML => svgHTML += barHTML);
    
    // Barra lateral de colores de bloque
    let blockY = headerHeight;
    let tempBlock = 0;
    tasks.forEach((task) => {
        if(task.block !== tempBlock) {
            svgHTML += `<rect x="0" y="${blockY}" width="5" height="${tasks.filter(t=>t.block===task.block).length * rowHeight}" class="color-b${task.block}" />`;
            tempBlock = task.block;
        }
        blockY += rowHeight;
    });
    
    taskNamesHTML.forEach(nameHTML => svgHTML += nameHTML);

    svgHTML += `</svg>`;
    document.getElementById('chart-container').innerHTML = svgHTML;

    // --- TOOLTIP ---
    const tooltip = document.getElementById('tooltip');
    window.showTooltip = (evt, text) => {
        tooltip.innerHTML = text;
        tooltip.style.opacity = 1;
        // Ajuste para que no se salga de la pantalla
        let left = evt.pageX + 15;
        if (left + 200 > window.innerWidth) left = evt.pageX - 215;
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = (evt.pageY + 15) + 'px';
    };
    window.hideTooltip = () => {
        tooltip.style.opacity = 0;
    };

</script>
</body>
</html>
